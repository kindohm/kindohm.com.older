---
layout: post
title: "Building an Asteroids Game Clone in JavaScript with Coquette"
---

<blockquote><em>"A micro framework for JavaScript games"</em></blockquote>

<h3>Live Demo</h3>

<p>Keyboard left/right arrows to rotate. Up arrow to thrust.</p>

<canvas id="canvas"></canvas>

<link href='http://fonts.googleapis.com/css?family=Ubuntu' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="/apps/coquette-spaceship/js/sylvester.js"></script>
<script type="text/javascript" src="/apps/coquette-spaceship/js/coquette.js"></script>
<script type="text/javascript" src="/apps/coquette-spaceship/js/maths.js"></script>
<script type="text/javascript" src="/apps/coquette-spaceship/js/settings.js"></script>
<script type="text/javascript" src="/apps/coquette-spaceship/js/player.js"></script>
<script type="text/javascript" src="/apps/coquette-spaceship/js/game.js"></script>
<script type="text/javascript">
window.addEventListener('load', function() {
  var game = new Game("canvas", 600, 200);
  game.init();
});
</script>


<h3>TL;DR; Version</h3>

<p>Coquette: <a href="http://coquette.maryrosecook.com/">coquette.maryrosecook.com</a></p>
<p>Implementation of a flying/wrapping space ship: <a href="/apps/coquette-spaceship/">click here to play</a></p>
<p>Source code for just this post: <a href="https://github.com/kindohm/space-janitor/tree/basic-spaceship">github.com/kindohm/space-janitor/tree/basic-spaceship</a></p>

<p>Full repository code: <a href="https://github.com/kindohm/space-janitor">github.com/kindohm/space-janitor</a></p>

<h3>Long Version</h3>

<p>When I saw this tweet, I decided to build a clone of <a href="https://en.wikipedia.org/wiki/Asteroids_(video_game)">Asteroids</a> with Coquette:</p>

<blockquote class="twitter-tweet"><p>Here is Coquette, a micro framework I made for JavaScript games: <a href="http://t.co/9x2yI96zyf" title="http://coquette.maryrosecook.com">coquette.maryrosecook.com</a></p>&mdash; Mary Rose Cook (@maryrosecook) <a href="https://twitter.com/maryrosecook/status/333955011656683520">May 13, 2013</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>(thanks to <a href="https://twitter.com/gelicia">@gelicia</a> for RT'ing it)</p>

<p>I thought it would be cool to write about my progress as I go, so this is
	the first installment: implementing a flying ship.</p>

<p><a href="/apps/coquette-spaceship/">
	<img src="/apps/coquette-spaceship/screenshot.png" alt="space ship" /></a></p>

<h4>Requirements and Constraints</h4>

<p>For this game, I wanted to have a simple ship with the following controls:</p>

<ul>
	<li>Left/right arrow keys: rotate the ship left or right</li>
	<li>Up arrow key: thrust</li>
</ul>

<p>Other game/environment constraints:</p>

<ul>
	<li>Wrap the spaceship top-to-bottom, bottom-to-top, left-to-right, or 
		right-to-left when it reaches the bounds of the canvas</li>
</ul>

<p>Shooting will come later...</p>

<h4>Overview of Game Objects</h4>

<p>There are only two relevant game objects in this prototype: <code>Game</code> 
	and <code>Player</code>. After the game is created (see Coquette docs for
	the basics), creating the Player is trivial:</p>

<pre><code>this.coquette.entities.create(Player, {
	pos: { 
	  x: gameWidth / 2, 
	  y: gameHeight / 2 
	},
	maxPos: { 
	  x: gameWwidth, 
	  y: gameHeight 
	}
});</code></pre>

<p>This code places the player at the center of the game canvas. Notice the
	use of the <code>maxPos</code> field. This is what the player object will
	use to control what its horizontal and vertical bounds are before "wrapping"
	to the other side of the screen.</p>

<p>The player object looks something like this:</p>

<pre><code>function Player(game, settings){

	var self = this;
	this.pos = settings.pos;
	this.maxPos = settings.maxPos;
	this.game = game;

	this.size = { 
	  x: game.settings.PLAYER_SIZE_X,
	  y: game.settings.PLAYER_SIZE_Y 
	};

	this.halfSize = {
	  x: this.size.x / 2,
	  y: this.size.y / 2
	};

	this.sprite = new Image();
	this.sprite.onload = function(){
	  self.spriteReady = true;
	};
	this.sprite.src = 'sprites/player.png';
}

Player.prototype = {

	vel:          {x: 0,  y: 0},
	spriteReady:  false,
	angle:        180,
	rAngle:       3.14,
	angleVector:  {x: 0, y: 0}, 
	thrust:       {x: 0, y: 0},
	thrusting:    false,
	thrustScale:  0,

	update: function (){ ... },
	draw: function(){ ... },
	rotate: function(direction){ ... },
	applyThrust: function (){ ... },
	idleThrust: function (){ ... },
	handleKeyboard: function(){ ... }
};</code></pre>

<p>In the player's constructor I'm simply initializing the position, size,
	and player sprite (an image).</p>

<p>The remaining fields and functions in the player prototype are where some
	of the more interesting stuff happens, so let's dig in to those next.</p>

<h4>update()</h4>

<p>Coquette calls <code>update()</code> for us after we've created the player
	as an entity. In <code>update()</code> I do a few things:</p>

<ul>
	<li>Handle keyboard input</li>
	<li>Change the player's velocity based on its thrust</li>
	<li>Move the player based on its velocity</li>
	<li>Wrap the player to the other side of the screen if it has gone
		"out of bounds"</li>
</ul>

<pre><code>update: function (){

	this.handleKeyboard();

	// change velocity
	this.vel.x += this.thrust.x;
	this.vel.y += this.thrust.y;

	// move
	this.pos.x += this.vel.x;
	this.pos.y += this.vel.y;

	// check x out-of-bounds
	if (this.pos.x &gt; this.maxPos.x) {
		this.pos.x = -this.size.x;
	} else if (this.pos.x &lt; -this.size.x) {
		this.pos.x = this.maxPos.x;
	}

	// check y out-of-bounds
	if (this.pos.y &gt; this.maxPos.y) {
		this.pos.y = -this.size.y;
	} else if (this.pos.y &lt; -this.size.y) {
		this.pos.y = this.maxPos.y;
	}
}</code></pre>
<br/>
<h4>.rotate() and .applyThrust()</h4>

<p><code>rotate()</code> does a little math, and no more. Depending on which
	direction (left or right) the user wants the ship to rotate, it increments
	the <code>angle</code> (degrees) and <code>rAngle</code> (radians) fields
	in the appropriate direction. I make use of Mary's Maths.js code to do the
	heavy lifting with <code>dial()</code> and <code>degToRad()</code>:</p>

<pre><code>rotate: function(direction){      
  var delta = this.game.settings.PLAYER_ROTATE_DELTA;
  this.angle = this.game.maths.dial(this.angle, direction === 'right' ? 
    delta : -delta, 359);
  this.rAngle = this.game.maths.degToRad(this.angle);
}</code></pre>

<p>The delta value is stored in settings.js and can be changed to make the
	rotation speed slower or faster.</p>

<p><code>applyThrust()</code> also just does a little math:</p>

<pre><code>applyThrust: function (){
  this.thrustScale = this.game.settings.PLAYER_THRUST_DELTA;
  var vector = this.game.maths.angleToVector(this.angle);
  this.thrust.x = vector.x * this.thrustScale;
  this.thrust.y = vector.y * this.thrustScale;
  this.thrusting = true;
}</code></pre>

<p>Here, I calculate the direction of the thrust based on the angle that the
	ship is pointing. I then calculate the scale of the thrust vector by multiplying
	the direction vector times a thrust delta amount, which can be found in settings.js.</p>

<p>The main goal of this method is to set the <code>thrust</code> vector field,
	which is used in <code>update()</code>.</p>

<h4>.draw()</h4>

<p>Last, after all the math has been done from the <code>update()</code> method,
	we draw the ship on the canvas. Drawing the player sprite is easy with
<code>drawImage()</code>, except that we have to rotate the image. This is done
using standard HTML 5 canvas context save-translate-rotate techniques:</p>

<pre><code>draw: function(context){

  // rotate the canvas to the angle our ship is at
  context.save();
  context.translate(this.pos.x + this.halfSize.x, 
    this.pos.y + this.halfSize.y);
  context.rotate(this.rAngle);

  // draw the ship sprite
  context.drawImage(this.sprite, -this.halfSize.x, -this.halfSize.y,
    this.size.x, this.size.y);

  // rotate the canvas back to its original position
  context.rotate(-this.Angle);
  context.translate(-(this.pos.x), -(this.pos.y));
  context.restore();      
}</code></pre>

<h3>Wrap-Up</h3>

<p>Getting this little prototype working was very, very easy with Coquette.
	I give credit to Mary for making a great game framework: you hardly notice
	the framework while focusing on your game code.</p>

<p>Stay tuned for a few more posts about:</p>

<ul>
	<li>Adding the ability to shoot bullets/lasers/projectiles</li>
	<li>Adding a thrust/engine effect</li>
	<li>Adding sound effects</li>
</ul>
